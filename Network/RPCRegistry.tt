<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>

using System;
using System.Collections.Generic;
using System.Reflection;
using Equinox.Utils.Stream;
using VRage;
namespace Equinox.Utils.Network
{
<#
    Func<int, string, string> generator = (a,b)=> {
        var str = new StringBuilder();
        for (var i = 1; i<=a; i++) {
            if (i>1) str.Append(", ");
            str.AppendFormat(b, i);
        }
        return str.ToString();
        };
    const string FormatType= "T{0}";
    const string FormatInType= "in T{0}";
    const string FormatParam = "T{0} p{0}";
    const string FormatRefParam = "ref T{0} p{0}";
    const string FormatArgs = "p{0}";
    const string FormatRefArgs = "ref p{0}";
    const int MaxArguments = 8;

    for (int args= 0; args<=MaxArguments; args++) {
#>
    public delegate void SyncAction<#=args==0?"":"<"+generator(args, FormatInType)+">"#>(<#=generator(args, FormatParam)#>);
<#
    }
#>
    public static class RPCRegistry
    {
        public abstract class SyncActionRegistrationBase
        {
            public abstract ulong HashKey { get; }
            public abstract void InvokeFrom(MemoryStream stream);
        }

        private static readonly FastResourceLock Lock = new FastResourceLock();
        private static readonly Dictionary<MemberInfo, SyncActionRegistrationBase> ActionRegistration = new Dictionary<MemberInfo, SyncActionRegistrationBase>();
        private static readonly Dictionary<ulong, SyncActionRegistrationBase> HashKeyRegistration = new Dictionary<ulong, SyncActionRegistrationBase>();

        public static SyncActionRegistrationBase GetByKey(ulong hashKey)
        {
            return HashKeyRegistration[hashKey];
        }

#region AutoGenerated
<#
    int[] PrimeNumbers = {74933, 52391, 45491, 32401, 27953, 76801, 76913, 77029, 77167, 77359, 77479, 77557, 77647, 77731, 77849, 77983, 79627, 79757, 79843, 79943, 80071, 80177, 80273, 80387, 80527, 80819, 80929, 81509, 81611, 81701, 81817};
    for (int args =0; args<=MaxArguments; args++) {
        var typestr= args == 0 ? "" : "<" + generator(args, FormatType) + ">";
        var parmstr= generator(args, FormatParam);
        var argstr= generator(args, FormatArgs);
        var optcomma = args>0?", ":"";
#>
        private static ulong ComputeHash<#=typestr#>(SyncAction<#=typestr#> act)
        {
            var seed = (ulong) 104729;
            seed *= act.Method.Name.Hash64();
<#
        for (var i = 1; i <= args; i++) {
#>
            seed ^= typeof(T<#=i#>).FullName.Hash64() * <#=PrimeNumbers[i % PrimeNumbers.Length]#>;
<#
        }
#>
            return seed;
        }

        public class SyncActionRegistration<#=typestr#> : SyncActionRegistrationBase
        {
            public override ulong HashKey { get; }
            private readonly SyncAction<#=typestr#> m_action;
<#
        for (var i = 1; i <= args; i++) {
#>
            private readonly Serializer<T<#=i#>> m_serializer<#=i#>;
<#
        }
#>

            public SyncActionRegistration(SyncAction<#=typestr#> act)
            {
                HashKey = ComputeHash(act);
                m_action = act;
<#
        for (var i = 1; i <= args; i++) {
#>
                m_serializer<#=i#> = SerializerRegistry.Get<T<#=i#>>();
<#
        }
#>
            }
            public void WriteArguments(MemoryStream output<#=optcomma#><#=generator(args, FormatRefParam)#>)
            {
<#
        for (var i = 1; i <= args; i++) {
#>
                m_serializer<#=i#>.Write(ref p<#=i#>, output);
<#
        }
#>
            }

            public override void InvokeFrom(MemoryStream input)
            {
<#
        for (var i = 1; i <= args; i++) {
#>
                var p<#=i#> = default(T<#=i#>);
                m_serializer<#=i#>.Read(ref p<#=i#>, input);
<#
        }
#>
                m_action.Invoke(<#=argstr#>);
            }
        }

        public static SyncActionRegistration<#=typestr#> Register<#=typestr#>(SyncAction<#=typestr#> act) {
            using(Lock.AcquireExclusiveUsing()) {
                var register = new SyncActionRegistration<#=typestr#>(act);
                ActionRegistration.Add(act.Method, register);
                if (HashKeyRegistration.ContainsKey(register.HashKey))
                    throw new ArgumentException("Unable to register delegate.  Try using a unique name.");
                HashKeyRegistration.Add(register.HashKey, register);
                return register;
            }
        }

        public static void Unregister<#=typestr#>(SyncAction<#=typestr#> act) {
            using(Lock.AcquireExclusiveUsing()) {
                HashKeyRegistration.Remove(ActionRegistration[act.Method].HashKey);
                ActionRegistration.Remove(act.Method);
            }
        }

        public static SyncActionRegistration<#=typestr#> Get<#=typestr#>(SyncAction<#=typestr#> act)
        {
            using(Lock.AcquireSharedUsing()) {
                SyncActionRegistrationBase res;
                if (ActionRegistration.TryGetValue(act.Method, out res))
                    return (SyncActionRegistration<#=typestr#>) res;
            }
            return null;
        }
<#
        for (var i = 0; i<=1; i++) {
            foreach (var argFormat in new[]{FormatParam, FormatRefParam}) {
#>
        public static bool RaiseStaticAction<#=typestr#>(this RPCComponent component, SyncAction<#=i==1?"Registration":""#><#=typestr#> act <#=optcomma#><#=generator(args, argFormat)#>, EndpointId destination = default(EndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<RPCActionPacket>();
            bool result;
            try {
                var desc = <#=i==1?"act":"Get(act)"#>;
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream<#=optcomma#> <#=generator(args, FormatRefArgs)#>);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
<#
                if (args == 0) break;
            }
        }
    }
#>
#endregion

    }
}