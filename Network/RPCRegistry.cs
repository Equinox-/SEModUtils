
using System;
using System.Collections.Generic;
using System.Reflection;
using Equinox.Utils.Stream;
using VRage;
namespace Equinox.Utils.Network
{
    public delegate void SyncAction();
    public delegate void SyncAction<in T1>(T1 p1);
    public delegate void SyncAction<in T1, in T2>(T1 p1, T2 p2);
    public delegate void SyncAction<in T1, in T2, in T3>(T1 p1, T2 p2, T3 p3);
    public delegate void SyncAction<in T1, in T2, in T3, in T4>(T1 p1, T2 p2, T3 p3, T4 p4);
    public delegate void SyncAction<in T1, in T2, in T3, in T4, in T5>(T1 p1, T2 p2, T3 p3, T4 p4, T5 p5);
    public delegate void SyncAction<in T1, in T2, in T3, in T4, in T5, in T6>(T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6);
    public delegate void SyncAction<in T1, in T2, in T3, in T4, in T5, in T6, in T7>(T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7);
    public delegate void SyncAction<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8>(T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8);
    public static class RPCRegistry
    {
        public abstract class SyncActionRegistrationBase
        {
            public abstract ulong HashKey { get; }
            public abstract void InvokeFrom(MemoryStream stream);
        }

        private static readonly FastResourceLock Lock = new FastResourceLock();
        private static readonly Dictionary<MemberInfo, SyncActionRegistrationBase> ActionRegistration = new Dictionary<MemberInfo, SyncActionRegistrationBase>();
        private static readonly Dictionary<ulong, SyncActionRegistrationBase> HashKeyRegistration = new Dictionary<ulong, SyncActionRegistrationBase>();

        public static SyncActionRegistrationBase GetByKey(ulong hashKey)
        {
            return HashKeyRegistration[hashKey];
        }

#region AutoGenerated
        private static ulong ComputeHash(SyncAction act)
        {
            var seed = (ulong) 104729;
            seed *= act.Method.Name.Hash64();
            return seed;
        }

        public class SyncActionRegistration : SyncActionRegistrationBase
        {
            public override ulong HashKey { get; }
            private readonly SyncAction m_action;

            public SyncActionRegistration(SyncAction act)
            {
                HashKey = ComputeHash(act);
                m_action = act;
            }
            public void WriteArguments(MemoryStream output)
            {
            }

            public override void InvokeFrom(MemoryStream input)
            {
                m_action.Invoke();
            }
        }

        public static SyncActionRegistration Register(SyncAction act) {
            using(Lock.AcquireExclusiveUsing()) {
                var register = new SyncActionRegistration(act);
                ActionRegistration.Add(act.Method, register);
                if (HashKeyRegistration.ContainsKey(register.HashKey))
                    throw new ArgumentException("Unable to register delegate.  Try using a unique name.");
                HashKeyRegistration.Add(register.HashKey, register);
                return register;
            }
        }

        public static void Unregister(SyncAction act) {
            using(Lock.AcquireExclusiveUsing()) {
                HashKeyRegistration.Remove(ActionRegistration[act.Method].HashKey);
                ActionRegistration.Remove(act.Method);
            }
        }

        public static SyncActionRegistration Get(SyncAction act)
        {
            using(Lock.AcquireSharedUsing()) {
                SyncActionRegistrationBase res;
                if (ActionRegistration.TryGetValue(act.Method, out res))
                    return (SyncActionRegistration) res;
            }
            return null;
        }
        public static bool RaiseStaticAction(this RPCComponent component, SyncAction act , EndpointId destination = default(EndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<RPCActionPacket>();
            bool result;
            try {
                var desc = Get(act);
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream );
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        public static bool RaiseStaticAction(this RPCComponent component, SyncActionRegistration act , EndpointId destination = default(EndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<RPCActionPacket>();
            bool result;
            try {
                var desc = act;
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream );
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        private static ulong ComputeHash<T1>(SyncAction<T1> act)
        {
            var seed = (ulong) 104729;
            seed *= act.Method.Name.Hash64();
            seed ^= typeof(T1).FullName.Hash64() * 52391;
            return seed;
        }

        public class SyncActionRegistration<T1> : SyncActionRegistrationBase
        {
            public override ulong HashKey { get; }
            private readonly SyncAction<T1> m_action;
            private readonly Serializer<T1> m_serializer1;

            public SyncActionRegistration(SyncAction<T1> act)
            {
                HashKey = ComputeHash(act);
                m_action = act;
                m_serializer1 = SerializerRegistry.Get<T1>();
            }
            public void WriteArguments(MemoryStream output, ref T1 p1)
            {
                m_serializer1.Write(ref p1, output);
            }

            public override void InvokeFrom(MemoryStream input)
            {
                var p1 = default(T1);
                m_serializer1.Read(ref p1, input);
                m_action.Invoke(p1);
            }
        }

        public static SyncActionRegistration<T1> Register<T1>(SyncAction<T1> act) {
            using(Lock.AcquireExclusiveUsing()) {
                var register = new SyncActionRegistration<T1>(act);
                ActionRegistration.Add(act.Method, register);
                if (HashKeyRegistration.ContainsKey(register.HashKey))
                    throw new ArgumentException("Unable to register delegate.  Try using a unique name.");
                HashKeyRegistration.Add(register.HashKey, register);
                return register;
            }
        }

        public static void Unregister<T1>(SyncAction<T1> act) {
            using(Lock.AcquireExclusiveUsing()) {
                HashKeyRegistration.Remove(ActionRegistration[act.Method].HashKey);
                ActionRegistration.Remove(act.Method);
            }
        }

        public static SyncActionRegistration<T1> Get<T1>(SyncAction<T1> act)
        {
            using(Lock.AcquireSharedUsing()) {
                SyncActionRegistrationBase res;
                if (ActionRegistration.TryGetValue(act.Method, out res))
                    return (SyncActionRegistration<T1>) res;
            }
            return null;
        }
        public static bool RaiseStaticAction<T1>(this RPCComponent component, SyncAction<T1> act , T1 p1, EndpointId destination = default(EndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<RPCActionPacket>();
            bool result;
            try {
                var desc = Get(act);
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        public static bool RaiseStaticAction<T1>(this RPCComponent component, SyncAction<T1> act , ref T1 p1, EndpointId destination = default(EndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<RPCActionPacket>();
            bool result;
            try {
                var desc = Get(act);
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        public static bool RaiseStaticAction<T1>(this RPCComponent component, SyncActionRegistration<T1> act , T1 p1, EndpointId destination = default(EndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<RPCActionPacket>();
            bool result;
            try {
                var desc = act;
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        public static bool RaiseStaticAction<T1>(this RPCComponent component, SyncActionRegistration<T1> act , ref T1 p1, EndpointId destination = default(EndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<RPCActionPacket>();
            bool result;
            try {
                var desc = act;
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        private static ulong ComputeHash<T1, T2>(SyncAction<T1, T2> act)
        {
            var seed = (ulong) 104729;
            seed *= act.Method.Name.Hash64();
            seed ^= typeof(T1).FullName.Hash64() * 52391;
            seed ^= typeof(T2).FullName.Hash64() * 45491;
            return seed;
        }

        public class SyncActionRegistration<T1, T2> : SyncActionRegistrationBase
        {
            public override ulong HashKey { get; }
            private readonly SyncAction<T1, T2> m_action;
            private readonly Serializer<T1> m_serializer1;
            private readonly Serializer<T2> m_serializer2;

            public SyncActionRegistration(SyncAction<T1, T2> act)
            {
                HashKey = ComputeHash(act);
                m_action = act;
                m_serializer1 = SerializerRegistry.Get<T1>();
                m_serializer2 = SerializerRegistry.Get<T2>();
            }
            public void WriteArguments(MemoryStream output, ref T1 p1, ref T2 p2)
            {
                m_serializer1.Write(ref p1, output);
                m_serializer2.Write(ref p2, output);
            }

            public override void InvokeFrom(MemoryStream input)
            {
                var p1 = default(T1);
                m_serializer1.Read(ref p1, input);
                var p2 = default(T2);
                m_serializer2.Read(ref p2, input);
                m_action.Invoke(p1, p2);
            }
        }

        public static SyncActionRegistration<T1, T2> Register<T1, T2>(SyncAction<T1, T2> act) {
            using(Lock.AcquireExclusiveUsing()) {
                var register = new SyncActionRegistration<T1, T2>(act);
                ActionRegistration.Add(act.Method, register);
                if (HashKeyRegistration.ContainsKey(register.HashKey))
                    throw new ArgumentException("Unable to register delegate.  Try using a unique name.");
                HashKeyRegistration.Add(register.HashKey, register);
                return register;
            }
        }

        public static void Unregister<T1, T2>(SyncAction<T1, T2> act) {
            using(Lock.AcquireExclusiveUsing()) {
                HashKeyRegistration.Remove(ActionRegistration[act.Method].HashKey);
                ActionRegistration.Remove(act.Method);
            }
        }

        public static SyncActionRegistration<T1, T2> Get<T1, T2>(SyncAction<T1, T2> act)
        {
            using(Lock.AcquireSharedUsing()) {
                SyncActionRegistrationBase res;
                if (ActionRegistration.TryGetValue(act.Method, out res))
                    return (SyncActionRegistration<T1, T2>) res;
            }
            return null;
        }
        public static bool RaiseStaticAction<T1, T2>(this RPCComponent component, SyncAction<T1, T2> act , T1 p1, T2 p2, EndpointId destination = default(EndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<RPCActionPacket>();
            bool result;
            try {
                var desc = Get(act);
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1, ref p2);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        public static bool RaiseStaticAction<T1, T2>(this RPCComponent component, SyncAction<T1, T2> act , ref T1 p1, ref T2 p2, EndpointId destination = default(EndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<RPCActionPacket>();
            bool result;
            try {
                var desc = Get(act);
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1, ref p2);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        public static bool RaiseStaticAction<T1, T2>(this RPCComponent component, SyncActionRegistration<T1, T2> act , T1 p1, T2 p2, EndpointId destination = default(EndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<RPCActionPacket>();
            bool result;
            try {
                var desc = act;
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1, ref p2);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        public static bool RaiseStaticAction<T1, T2>(this RPCComponent component, SyncActionRegistration<T1, T2> act , ref T1 p1, ref T2 p2, EndpointId destination = default(EndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<RPCActionPacket>();
            bool result;
            try {
                var desc = act;
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1, ref p2);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        private static ulong ComputeHash<T1, T2, T3>(SyncAction<T1, T2, T3> act)
        {
            var seed = (ulong) 104729;
            seed *= act.Method.Name.Hash64();
            seed ^= typeof(T1).FullName.Hash64() * 52391;
            seed ^= typeof(T2).FullName.Hash64() * 45491;
            seed ^= typeof(T3).FullName.Hash64() * 32401;
            return seed;
        }

        public class SyncActionRegistration<T1, T2, T3> : SyncActionRegistrationBase
        {
            public override ulong HashKey { get; }
            private readonly SyncAction<T1, T2, T3> m_action;
            private readonly Serializer<T1> m_serializer1;
            private readonly Serializer<T2> m_serializer2;
            private readonly Serializer<T3> m_serializer3;

            public SyncActionRegistration(SyncAction<T1, T2, T3> act)
            {
                HashKey = ComputeHash(act);
                m_action = act;
                m_serializer1 = SerializerRegistry.Get<T1>();
                m_serializer2 = SerializerRegistry.Get<T2>();
                m_serializer3 = SerializerRegistry.Get<T3>();
            }
            public void WriteArguments(MemoryStream output, ref T1 p1, ref T2 p2, ref T3 p3)
            {
                m_serializer1.Write(ref p1, output);
                m_serializer2.Write(ref p2, output);
                m_serializer3.Write(ref p3, output);
            }

            public override void InvokeFrom(MemoryStream input)
            {
                var p1 = default(T1);
                m_serializer1.Read(ref p1, input);
                var p2 = default(T2);
                m_serializer2.Read(ref p2, input);
                var p3 = default(T3);
                m_serializer3.Read(ref p3, input);
                m_action.Invoke(p1, p2, p3);
            }
        }

        public static SyncActionRegistration<T1, T2, T3> Register<T1, T2, T3>(SyncAction<T1, T2, T3> act) {
            using(Lock.AcquireExclusiveUsing()) {
                var register = new SyncActionRegistration<T1, T2, T3>(act);
                ActionRegistration.Add(act.Method, register);
                if (HashKeyRegistration.ContainsKey(register.HashKey))
                    throw new ArgumentException("Unable to register delegate.  Try using a unique name.");
                HashKeyRegistration.Add(register.HashKey, register);
                return register;
            }
        }

        public static void Unregister<T1, T2, T3>(SyncAction<T1, T2, T3> act) {
            using(Lock.AcquireExclusiveUsing()) {
                HashKeyRegistration.Remove(ActionRegistration[act.Method].HashKey);
                ActionRegistration.Remove(act.Method);
            }
        }

        public static SyncActionRegistration<T1, T2, T3> Get<T1, T2, T3>(SyncAction<T1, T2, T3> act)
        {
            using(Lock.AcquireSharedUsing()) {
                SyncActionRegistrationBase res;
                if (ActionRegistration.TryGetValue(act.Method, out res))
                    return (SyncActionRegistration<T1, T2, T3>) res;
            }
            return null;
        }
        public static bool RaiseStaticAction<T1, T2, T3>(this RPCComponent component, SyncAction<T1, T2, T3> act , T1 p1, T2 p2, T3 p3, EndpointId destination = default(EndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<RPCActionPacket>();
            bool result;
            try {
                var desc = Get(act);
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1, ref p2, ref p3);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        public static bool RaiseStaticAction<T1, T2, T3>(this RPCComponent component, SyncAction<T1, T2, T3> act , ref T1 p1, ref T2 p2, ref T3 p3, EndpointId destination = default(EndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<RPCActionPacket>();
            bool result;
            try {
                var desc = Get(act);
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1, ref p2, ref p3);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        public static bool RaiseStaticAction<T1, T2, T3>(this RPCComponent component, SyncActionRegistration<T1, T2, T3> act , T1 p1, T2 p2, T3 p3, EndpointId destination = default(EndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<RPCActionPacket>();
            bool result;
            try {
                var desc = act;
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1, ref p2, ref p3);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        public static bool RaiseStaticAction<T1, T2, T3>(this RPCComponent component, SyncActionRegistration<T1, T2, T3> act , ref T1 p1, ref T2 p2, ref T3 p3, EndpointId destination = default(EndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<RPCActionPacket>();
            bool result;
            try {
                var desc = act;
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1, ref p2, ref p3);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        private static ulong ComputeHash<T1, T2, T3, T4>(SyncAction<T1, T2, T3, T4> act)
        {
            var seed = (ulong) 104729;
            seed *= act.Method.Name.Hash64();
            seed ^= typeof(T1).FullName.Hash64() * 52391;
            seed ^= typeof(T2).FullName.Hash64() * 45491;
            seed ^= typeof(T3).FullName.Hash64() * 32401;
            seed ^= typeof(T4).FullName.Hash64() * 27953;
            return seed;
        }

        public class SyncActionRegistration<T1, T2, T3, T4> : SyncActionRegistrationBase
        {
            public override ulong HashKey { get; }
            private readonly SyncAction<T1, T2, T3, T4> m_action;
            private readonly Serializer<T1> m_serializer1;
            private readonly Serializer<T2> m_serializer2;
            private readonly Serializer<T3> m_serializer3;
            private readonly Serializer<T4> m_serializer4;

            public SyncActionRegistration(SyncAction<T1, T2, T3, T4> act)
            {
                HashKey = ComputeHash(act);
                m_action = act;
                m_serializer1 = SerializerRegistry.Get<T1>();
                m_serializer2 = SerializerRegistry.Get<T2>();
                m_serializer3 = SerializerRegistry.Get<T3>();
                m_serializer4 = SerializerRegistry.Get<T4>();
            }
            public void WriteArguments(MemoryStream output, ref T1 p1, ref T2 p2, ref T3 p3, ref T4 p4)
            {
                m_serializer1.Write(ref p1, output);
                m_serializer2.Write(ref p2, output);
                m_serializer3.Write(ref p3, output);
                m_serializer4.Write(ref p4, output);
            }

            public override void InvokeFrom(MemoryStream input)
            {
                var p1 = default(T1);
                m_serializer1.Read(ref p1, input);
                var p2 = default(T2);
                m_serializer2.Read(ref p2, input);
                var p3 = default(T3);
                m_serializer3.Read(ref p3, input);
                var p4 = default(T4);
                m_serializer4.Read(ref p4, input);
                m_action.Invoke(p1, p2, p3, p4);
            }
        }

        public static SyncActionRegistration<T1, T2, T3, T4> Register<T1, T2, T3, T4>(SyncAction<T1, T2, T3, T4> act) {
            using(Lock.AcquireExclusiveUsing()) {
                var register = new SyncActionRegistration<T1, T2, T3, T4>(act);
                ActionRegistration.Add(act.Method, register);
                if (HashKeyRegistration.ContainsKey(register.HashKey))
                    throw new ArgumentException("Unable to register delegate.  Try using a unique name.");
                HashKeyRegistration.Add(register.HashKey, register);
                return register;
            }
        }

        public static void Unregister<T1, T2, T3, T4>(SyncAction<T1, T2, T3, T4> act) {
            using(Lock.AcquireExclusiveUsing()) {
                HashKeyRegistration.Remove(ActionRegistration[act.Method].HashKey);
                ActionRegistration.Remove(act.Method);
            }
        }

        public static SyncActionRegistration<T1, T2, T3, T4> Get<T1, T2, T3, T4>(SyncAction<T1, T2, T3, T4> act)
        {
            using(Lock.AcquireSharedUsing()) {
                SyncActionRegistrationBase res;
                if (ActionRegistration.TryGetValue(act.Method, out res))
                    return (SyncActionRegistration<T1, T2, T3, T4>) res;
            }
            return null;
        }
        public static bool RaiseStaticAction<T1, T2, T3, T4>(this RPCComponent component, SyncAction<T1, T2, T3, T4> act , T1 p1, T2 p2, T3 p3, T4 p4, EndpointId destination = default(EndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<RPCActionPacket>();
            bool result;
            try {
                var desc = Get(act);
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1, ref p2, ref p3, ref p4);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        public static bool RaiseStaticAction<T1, T2, T3, T4>(this RPCComponent component, SyncAction<T1, T2, T3, T4> act , ref T1 p1, ref T2 p2, ref T3 p3, ref T4 p4, EndpointId destination = default(EndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<RPCActionPacket>();
            bool result;
            try {
                var desc = Get(act);
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1, ref p2, ref p3, ref p4);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        public static bool RaiseStaticAction<T1, T2, T3, T4>(this RPCComponent component, SyncActionRegistration<T1, T2, T3, T4> act , T1 p1, T2 p2, T3 p3, T4 p4, EndpointId destination = default(EndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<RPCActionPacket>();
            bool result;
            try {
                var desc = act;
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1, ref p2, ref p3, ref p4);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        public static bool RaiseStaticAction<T1, T2, T3, T4>(this RPCComponent component, SyncActionRegistration<T1, T2, T3, T4> act , ref T1 p1, ref T2 p2, ref T3 p3, ref T4 p4, EndpointId destination = default(EndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<RPCActionPacket>();
            bool result;
            try {
                var desc = act;
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1, ref p2, ref p3, ref p4);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        private static ulong ComputeHash<T1, T2, T3, T4, T5>(SyncAction<T1, T2, T3, T4, T5> act)
        {
            var seed = (ulong) 104729;
            seed *= act.Method.Name.Hash64();
            seed ^= typeof(T1).FullName.Hash64() * 52391;
            seed ^= typeof(T2).FullName.Hash64() * 45491;
            seed ^= typeof(T3).FullName.Hash64() * 32401;
            seed ^= typeof(T4).FullName.Hash64() * 27953;
            seed ^= typeof(T5).FullName.Hash64() * 76801;
            return seed;
        }

        public class SyncActionRegistration<T1, T2, T3, T4, T5> : SyncActionRegistrationBase
        {
            public override ulong HashKey { get; }
            private readonly SyncAction<T1, T2, T3, T4, T5> m_action;
            private readonly Serializer<T1> m_serializer1;
            private readonly Serializer<T2> m_serializer2;
            private readonly Serializer<T3> m_serializer3;
            private readonly Serializer<T4> m_serializer4;
            private readonly Serializer<T5> m_serializer5;

            public SyncActionRegistration(SyncAction<T1, T2, T3, T4, T5> act)
            {
                HashKey = ComputeHash(act);
                m_action = act;
                m_serializer1 = SerializerRegistry.Get<T1>();
                m_serializer2 = SerializerRegistry.Get<T2>();
                m_serializer3 = SerializerRegistry.Get<T3>();
                m_serializer4 = SerializerRegistry.Get<T4>();
                m_serializer5 = SerializerRegistry.Get<T5>();
            }
            public void WriteArguments(MemoryStream output, ref T1 p1, ref T2 p2, ref T3 p3, ref T4 p4, ref T5 p5)
            {
                m_serializer1.Write(ref p1, output);
                m_serializer2.Write(ref p2, output);
                m_serializer3.Write(ref p3, output);
                m_serializer4.Write(ref p4, output);
                m_serializer5.Write(ref p5, output);
            }

            public override void InvokeFrom(MemoryStream input)
            {
                var p1 = default(T1);
                m_serializer1.Read(ref p1, input);
                var p2 = default(T2);
                m_serializer2.Read(ref p2, input);
                var p3 = default(T3);
                m_serializer3.Read(ref p3, input);
                var p4 = default(T4);
                m_serializer4.Read(ref p4, input);
                var p5 = default(T5);
                m_serializer5.Read(ref p5, input);
                m_action.Invoke(p1, p2, p3, p4, p5);
            }
        }

        public static SyncActionRegistration<T1, T2, T3, T4, T5> Register<T1, T2, T3, T4, T5>(SyncAction<T1, T2, T3, T4, T5> act) {
            using(Lock.AcquireExclusiveUsing()) {
                var register = new SyncActionRegistration<T1, T2, T3, T4, T5>(act);
                ActionRegistration.Add(act.Method, register);
                if (HashKeyRegistration.ContainsKey(register.HashKey))
                    throw new ArgumentException("Unable to register delegate.  Try using a unique name.");
                HashKeyRegistration.Add(register.HashKey, register);
                return register;
            }
        }

        public static void Unregister<T1, T2, T3, T4, T5>(SyncAction<T1, T2, T3, T4, T5> act) {
            using(Lock.AcquireExclusiveUsing()) {
                HashKeyRegistration.Remove(ActionRegistration[act.Method].HashKey);
                ActionRegistration.Remove(act.Method);
            }
        }

        public static SyncActionRegistration<T1, T2, T3, T4, T5> Get<T1, T2, T3, T4, T5>(SyncAction<T1, T2, T3, T4, T5> act)
        {
            using(Lock.AcquireSharedUsing()) {
                SyncActionRegistrationBase res;
                if (ActionRegistration.TryGetValue(act.Method, out res))
                    return (SyncActionRegistration<T1, T2, T3, T4, T5>) res;
            }
            return null;
        }
        public static bool RaiseStaticAction<T1, T2, T3, T4, T5>(this RPCComponent component, SyncAction<T1, T2, T3, T4, T5> act , T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, EndpointId destination = default(EndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<RPCActionPacket>();
            bool result;
            try {
                var desc = Get(act);
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1, ref p2, ref p3, ref p4, ref p5);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        public static bool RaiseStaticAction<T1, T2, T3, T4, T5>(this RPCComponent component, SyncAction<T1, T2, T3, T4, T5> act , ref T1 p1, ref T2 p2, ref T3 p3, ref T4 p4, ref T5 p5, EndpointId destination = default(EndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<RPCActionPacket>();
            bool result;
            try {
                var desc = Get(act);
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1, ref p2, ref p3, ref p4, ref p5);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        public static bool RaiseStaticAction<T1, T2, T3, T4, T5>(this RPCComponent component, SyncActionRegistration<T1, T2, T3, T4, T5> act , T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, EndpointId destination = default(EndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<RPCActionPacket>();
            bool result;
            try {
                var desc = act;
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1, ref p2, ref p3, ref p4, ref p5);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        public static bool RaiseStaticAction<T1, T2, T3, T4, T5>(this RPCComponent component, SyncActionRegistration<T1, T2, T3, T4, T5> act , ref T1 p1, ref T2 p2, ref T3 p3, ref T4 p4, ref T5 p5, EndpointId destination = default(EndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<RPCActionPacket>();
            bool result;
            try {
                var desc = act;
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1, ref p2, ref p3, ref p4, ref p5);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        private static ulong ComputeHash<T1, T2, T3, T4, T5, T6>(SyncAction<T1, T2, T3, T4, T5, T6> act)
        {
            var seed = (ulong) 104729;
            seed *= act.Method.Name.Hash64();
            seed ^= typeof(T1).FullName.Hash64() * 52391;
            seed ^= typeof(T2).FullName.Hash64() * 45491;
            seed ^= typeof(T3).FullName.Hash64() * 32401;
            seed ^= typeof(T4).FullName.Hash64() * 27953;
            seed ^= typeof(T5).FullName.Hash64() * 76801;
            seed ^= typeof(T6).FullName.Hash64() * 76913;
            return seed;
        }

        public class SyncActionRegistration<T1, T2, T3, T4, T5, T6> : SyncActionRegistrationBase
        {
            public override ulong HashKey { get; }
            private readonly SyncAction<T1, T2, T3, T4, T5, T6> m_action;
            private readonly Serializer<T1> m_serializer1;
            private readonly Serializer<T2> m_serializer2;
            private readonly Serializer<T3> m_serializer3;
            private readonly Serializer<T4> m_serializer4;
            private readonly Serializer<T5> m_serializer5;
            private readonly Serializer<T6> m_serializer6;

            public SyncActionRegistration(SyncAction<T1, T2, T3, T4, T5, T6> act)
            {
                HashKey = ComputeHash(act);
                m_action = act;
                m_serializer1 = SerializerRegistry.Get<T1>();
                m_serializer2 = SerializerRegistry.Get<T2>();
                m_serializer3 = SerializerRegistry.Get<T3>();
                m_serializer4 = SerializerRegistry.Get<T4>();
                m_serializer5 = SerializerRegistry.Get<T5>();
                m_serializer6 = SerializerRegistry.Get<T6>();
            }
            public void WriteArguments(MemoryStream output, ref T1 p1, ref T2 p2, ref T3 p3, ref T4 p4, ref T5 p5, ref T6 p6)
            {
                m_serializer1.Write(ref p1, output);
                m_serializer2.Write(ref p2, output);
                m_serializer3.Write(ref p3, output);
                m_serializer4.Write(ref p4, output);
                m_serializer5.Write(ref p5, output);
                m_serializer6.Write(ref p6, output);
            }

            public override void InvokeFrom(MemoryStream input)
            {
                var p1 = default(T1);
                m_serializer1.Read(ref p1, input);
                var p2 = default(T2);
                m_serializer2.Read(ref p2, input);
                var p3 = default(T3);
                m_serializer3.Read(ref p3, input);
                var p4 = default(T4);
                m_serializer4.Read(ref p4, input);
                var p5 = default(T5);
                m_serializer5.Read(ref p5, input);
                var p6 = default(T6);
                m_serializer6.Read(ref p6, input);
                m_action.Invoke(p1, p2, p3, p4, p5, p6);
            }
        }

        public static SyncActionRegistration<T1, T2, T3, T4, T5, T6> Register<T1, T2, T3, T4, T5, T6>(SyncAction<T1, T2, T3, T4, T5, T6> act) {
            using(Lock.AcquireExclusiveUsing()) {
                var register = new SyncActionRegistration<T1, T2, T3, T4, T5, T6>(act);
                ActionRegistration.Add(act.Method, register);
                if (HashKeyRegistration.ContainsKey(register.HashKey))
                    throw new ArgumentException("Unable to register delegate.  Try using a unique name.");
                HashKeyRegistration.Add(register.HashKey, register);
                return register;
            }
        }

        public static void Unregister<T1, T2, T3, T4, T5, T6>(SyncAction<T1, T2, T3, T4, T5, T6> act) {
            using(Lock.AcquireExclusiveUsing()) {
                HashKeyRegistration.Remove(ActionRegistration[act.Method].HashKey);
                ActionRegistration.Remove(act.Method);
            }
        }

        public static SyncActionRegistration<T1, T2, T3, T4, T5, T6> Get<T1, T2, T3, T4, T5, T6>(SyncAction<T1, T2, T3, T4, T5, T6> act)
        {
            using(Lock.AcquireSharedUsing()) {
                SyncActionRegistrationBase res;
                if (ActionRegistration.TryGetValue(act.Method, out res))
                    return (SyncActionRegistration<T1, T2, T3, T4, T5, T6>) res;
            }
            return null;
        }
        public static bool RaiseStaticAction<T1, T2, T3, T4, T5, T6>(this RPCComponent component, SyncAction<T1, T2, T3, T4, T5, T6> act , T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, EndpointId destination = default(EndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<RPCActionPacket>();
            bool result;
            try {
                var desc = Get(act);
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1, ref p2, ref p3, ref p4, ref p5, ref p6);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        public static bool RaiseStaticAction<T1, T2, T3, T4, T5, T6>(this RPCComponent component, SyncAction<T1, T2, T3, T4, T5, T6> act , ref T1 p1, ref T2 p2, ref T3 p3, ref T4 p4, ref T5 p5, ref T6 p6, EndpointId destination = default(EndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<RPCActionPacket>();
            bool result;
            try {
                var desc = Get(act);
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1, ref p2, ref p3, ref p4, ref p5, ref p6);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        public static bool RaiseStaticAction<T1, T2, T3, T4, T5, T6>(this RPCComponent component, SyncActionRegistration<T1, T2, T3, T4, T5, T6> act , T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, EndpointId destination = default(EndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<RPCActionPacket>();
            bool result;
            try {
                var desc = act;
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1, ref p2, ref p3, ref p4, ref p5, ref p6);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        public static bool RaiseStaticAction<T1, T2, T3, T4, T5, T6>(this RPCComponent component, SyncActionRegistration<T1, T2, T3, T4, T5, T6> act , ref T1 p1, ref T2 p2, ref T3 p3, ref T4 p4, ref T5 p5, ref T6 p6, EndpointId destination = default(EndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<RPCActionPacket>();
            bool result;
            try {
                var desc = act;
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1, ref p2, ref p3, ref p4, ref p5, ref p6);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        private static ulong ComputeHash<T1, T2, T3, T4, T5, T6, T7>(SyncAction<T1, T2, T3, T4, T5, T6, T7> act)
        {
            var seed = (ulong) 104729;
            seed *= act.Method.Name.Hash64();
            seed ^= typeof(T1).FullName.Hash64() * 52391;
            seed ^= typeof(T2).FullName.Hash64() * 45491;
            seed ^= typeof(T3).FullName.Hash64() * 32401;
            seed ^= typeof(T4).FullName.Hash64() * 27953;
            seed ^= typeof(T5).FullName.Hash64() * 76801;
            seed ^= typeof(T6).FullName.Hash64() * 76913;
            seed ^= typeof(T7).FullName.Hash64() * 77029;
            return seed;
        }

        public class SyncActionRegistration<T1, T2, T3, T4, T5, T6, T7> : SyncActionRegistrationBase
        {
            public override ulong HashKey { get; }
            private readonly SyncAction<T1, T2, T3, T4, T5, T6, T7> m_action;
            private readonly Serializer<T1> m_serializer1;
            private readonly Serializer<T2> m_serializer2;
            private readonly Serializer<T3> m_serializer3;
            private readonly Serializer<T4> m_serializer4;
            private readonly Serializer<T5> m_serializer5;
            private readonly Serializer<T6> m_serializer6;
            private readonly Serializer<T7> m_serializer7;

            public SyncActionRegistration(SyncAction<T1, T2, T3, T4, T5, T6, T7> act)
            {
                HashKey = ComputeHash(act);
                m_action = act;
                m_serializer1 = SerializerRegistry.Get<T1>();
                m_serializer2 = SerializerRegistry.Get<T2>();
                m_serializer3 = SerializerRegistry.Get<T3>();
                m_serializer4 = SerializerRegistry.Get<T4>();
                m_serializer5 = SerializerRegistry.Get<T5>();
                m_serializer6 = SerializerRegistry.Get<T6>();
                m_serializer7 = SerializerRegistry.Get<T7>();
            }
            public void WriteArguments(MemoryStream output, ref T1 p1, ref T2 p2, ref T3 p3, ref T4 p4, ref T5 p5, ref T6 p6, ref T7 p7)
            {
                m_serializer1.Write(ref p1, output);
                m_serializer2.Write(ref p2, output);
                m_serializer3.Write(ref p3, output);
                m_serializer4.Write(ref p4, output);
                m_serializer5.Write(ref p5, output);
                m_serializer6.Write(ref p6, output);
                m_serializer7.Write(ref p7, output);
            }

            public override void InvokeFrom(MemoryStream input)
            {
                var p1 = default(T1);
                m_serializer1.Read(ref p1, input);
                var p2 = default(T2);
                m_serializer2.Read(ref p2, input);
                var p3 = default(T3);
                m_serializer3.Read(ref p3, input);
                var p4 = default(T4);
                m_serializer4.Read(ref p4, input);
                var p5 = default(T5);
                m_serializer5.Read(ref p5, input);
                var p6 = default(T6);
                m_serializer6.Read(ref p6, input);
                var p7 = default(T7);
                m_serializer7.Read(ref p7, input);
                m_action.Invoke(p1, p2, p3, p4, p5, p6, p7);
            }
        }

        public static SyncActionRegistration<T1, T2, T3, T4, T5, T6, T7> Register<T1, T2, T3, T4, T5, T6, T7>(SyncAction<T1, T2, T3, T4, T5, T6, T7> act) {
            using(Lock.AcquireExclusiveUsing()) {
                var register = new SyncActionRegistration<T1, T2, T3, T4, T5, T6, T7>(act);
                ActionRegistration.Add(act.Method, register);
                if (HashKeyRegistration.ContainsKey(register.HashKey))
                    throw new ArgumentException("Unable to register delegate.  Try using a unique name.");
                HashKeyRegistration.Add(register.HashKey, register);
                return register;
            }
        }

        public static void Unregister<T1, T2, T3, T4, T5, T6, T7>(SyncAction<T1, T2, T3, T4, T5, T6, T7> act) {
            using(Lock.AcquireExclusiveUsing()) {
                HashKeyRegistration.Remove(ActionRegistration[act.Method].HashKey);
                ActionRegistration.Remove(act.Method);
            }
        }

        public static SyncActionRegistration<T1, T2, T3, T4, T5, T6, T7> Get<T1, T2, T3, T4, T5, T6, T7>(SyncAction<T1, T2, T3, T4, T5, T6, T7> act)
        {
            using(Lock.AcquireSharedUsing()) {
                SyncActionRegistrationBase res;
                if (ActionRegistration.TryGetValue(act.Method, out res))
                    return (SyncActionRegistration<T1, T2, T3, T4, T5, T6, T7>) res;
            }
            return null;
        }
        public static bool RaiseStaticAction<T1, T2, T3, T4, T5, T6, T7>(this RPCComponent component, SyncAction<T1, T2, T3, T4, T5, T6, T7> act , T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, EndpointId destination = default(EndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<RPCActionPacket>();
            bool result;
            try {
                var desc = Get(act);
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1, ref p2, ref p3, ref p4, ref p5, ref p6, ref p7);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        public static bool RaiseStaticAction<T1, T2, T3, T4, T5, T6, T7>(this RPCComponent component, SyncAction<T1, T2, T3, T4, T5, T6, T7> act , ref T1 p1, ref T2 p2, ref T3 p3, ref T4 p4, ref T5 p5, ref T6 p6, ref T7 p7, EndpointId destination = default(EndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<RPCActionPacket>();
            bool result;
            try {
                var desc = Get(act);
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1, ref p2, ref p3, ref p4, ref p5, ref p6, ref p7);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        public static bool RaiseStaticAction<T1, T2, T3, T4, T5, T6, T7>(this RPCComponent component, SyncActionRegistration<T1, T2, T3, T4, T5, T6, T7> act , T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, EndpointId destination = default(EndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<RPCActionPacket>();
            bool result;
            try {
                var desc = act;
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1, ref p2, ref p3, ref p4, ref p5, ref p6, ref p7);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        public static bool RaiseStaticAction<T1, T2, T3, T4, T5, T6, T7>(this RPCComponent component, SyncActionRegistration<T1, T2, T3, T4, T5, T6, T7> act , ref T1 p1, ref T2 p2, ref T3 p3, ref T4 p4, ref T5 p5, ref T6 p6, ref T7 p7, EndpointId destination = default(EndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<RPCActionPacket>();
            bool result;
            try {
                var desc = act;
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1, ref p2, ref p3, ref p4, ref p5, ref p6, ref p7);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        private static ulong ComputeHash<T1, T2, T3, T4, T5, T6, T7, T8>(SyncAction<T1, T2, T3, T4, T5, T6, T7, T8> act)
        {
            var seed = (ulong) 104729;
            seed *= act.Method.Name.Hash64();
            seed ^= typeof(T1).FullName.Hash64() * 52391;
            seed ^= typeof(T2).FullName.Hash64() * 45491;
            seed ^= typeof(T3).FullName.Hash64() * 32401;
            seed ^= typeof(T4).FullName.Hash64() * 27953;
            seed ^= typeof(T5).FullName.Hash64() * 76801;
            seed ^= typeof(T6).FullName.Hash64() * 76913;
            seed ^= typeof(T7).FullName.Hash64() * 77029;
            seed ^= typeof(T8).FullName.Hash64() * 77167;
            return seed;
        }

        public class SyncActionRegistration<T1, T2, T3, T4, T5, T6, T7, T8> : SyncActionRegistrationBase
        {
            public override ulong HashKey { get; }
            private readonly SyncAction<T1, T2, T3, T4, T5, T6, T7, T8> m_action;
            private readonly Serializer<T1> m_serializer1;
            private readonly Serializer<T2> m_serializer2;
            private readonly Serializer<T3> m_serializer3;
            private readonly Serializer<T4> m_serializer4;
            private readonly Serializer<T5> m_serializer5;
            private readonly Serializer<T6> m_serializer6;
            private readonly Serializer<T7> m_serializer7;
            private readonly Serializer<T8> m_serializer8;

            public SyncActionRegistration(SyncAction<T1, T2, T3, T4, T5, T6, T7, T8> act)
            {
                HashKey = ComputeHash(act);
                m_action = act;
                m_serializer1 = SerializerRegistry.Get<T1>();
                m_serializer2 = SerializerRegistry.Get<T2>();
                m_serializer3 = SerializerRegistry.Get<T3>();
                m_serializer4 = SerializerRegistry.Get<T4>();
                m_serializer5 = SerializerRegistry.Get<T5>();
                m_serializer6 = SerializerRegistry.Get<T6>();
                m_serializer7 = SerializerRegistry.Get<T7>();
                m_serializer8 = SerializerRegistry.Get<T8>();
            }
            public void WriteArguments(MemoryStream output, ref T1 p1, ref T2 p2, ref T3 p3, ref T4 p4, ref T5 p5, ref T6 p6, ref T7 p7, ref T8 p8)
            {
                m_serializer1.Write(ref p1, output);
                m_serializer2.Write(ref p2, output);
                m_serializer3.Write(ref p3, output);
                m_serializer4.Write(ref p4, output);
                m_serializer5.Write(ref p5, output);
                m_serializer6.Write(ref p6, output);
                m_serializer7.Write(ref p7, output);
                m_serializer8.Write(ref p8, output);
            }

            public override void InvokeFrom(MemoryStream input)
            {
                var p1 = default(T1);
                m_serializer1.Read(ref p1, input);
                var p2 = default(T2);
                m_serializer2.Read(ref p2, input);
                var p3 = default(T3);
                m_serializer3.Read(ref p3, input);
                var p4 = default(T4);
                m_serializer4.Read(ref p4, input);
                var p5 = default(T5);
                m_serializer5.Read(ref p5, input);
                var p6 = default(T6);
                m_serializer6.Read(ref p6, input);
                var p7 = default(T7);
                m_serializer7.Read(ref p7, input);
                var p8 = default(T8);
                m_serializer8.Read(ref p8, input);
                m_action.Invoke(p1, p2, p3, p4, p5, p6, p7, p8);
            }
        }

        public static SyncActionRegistration<T1, T2, T3, T4, T5, T6, T7, T8> Register<T1, T2, T3, T4, T5, T6, T7, T8>(SyncAction<T1, T2, T3, T4, T5, T6, T7, T8> act) {
            using(Lock.AcquireExclusiveUsing()) {
                var register = new SyncActionRegistration<T1, T2, T3, T4, T5, T6, T7, T8>(act);
                ActionRegistration.Add(act.Method, register);
                if (HashKeyRegistration.ContainsKey(register.HashKey))
                    throw new ArgumentException("Unable to register delegate.  Try using a unique name.");
                HashKeyRegistration.Add(register.HashKey, register);
                return register;
            }
        }

        public static void Unregister<T1, T2, T3, T4, T5, T6, T7, T8>(SyncAction<T1, T2, T3, T4, T5, T6, T7, T8> act) {
            using(Lock.AcquireExclusiveUsing()) {
                HashKeyRegistration.Remove(ActionRegistration[act.Method].HashKey);
                ActionRegistration.Remove(act.Method);
            }
        }

        public static SyncActionRegistration<T1, T2, T3, T4, T5, T6, T7, T8> Get<T1, T2, T3, T4, T5, T6, T7, T8>(SyncAction<T1, T2, T3, T4, T5, T6, T7, T8> act)
        {
            using(Lock.AcquireSharedUsing()) {
                SyncActionRegistrationBase res;
                if (ActionRegistration.TryGetValue(act.Method, out res))
                    return (SyncActionRegistration<T1, T2, T3, T4, T5, T6, T7, T8>) res;
            }
            return null;
        }
        public static bool RaiseStaticAction<T1, T2, T3, T4, T5, T6, T7, T8>(this RPCComponent component, SyncAction<T1, T2, T3, T4, T5, T6, T7, T8> act , T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, EndpointId destination = default(EndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<RPCActionPacket>();
            bool result;
            try {
                var desc = Get(act);
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1, ref p2, ref p3, ref p4, ref p5, ref p6, ref p7, ref p8);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        public static bool RaiseStaticAction<T1, T2, T3, T4, T5, T6, T7, T8>(this RPCComponent component, SyncAction<T1, T2, T3, T4, T5, T6, T7, T8> act , ref T1 p1, ref T2 p2, ref T3 p3, ref T4 p4, ref T5 p5, ref T6 p6, ref T7 p7, ref T8 p8, EndpointId destination = default(EndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<RPCActionPacket>();
            bool result;
            try {
                var desc = Get(act);
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1, ref p2, ref p3, ref p4, ref p5, ref p6, ref p7, ref p8);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        public static bool RaiseStaticAction<T1, T2, T3, T4, T5, T6, T7, T8>(this RPCComponent component, SyncActionRegistration<T1, T2, T3, T4, T5, T6, T7, T8> act , T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, EndpointId destination = default(EndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<RPCActionPacket>();
            bool result;
            try {
                var desc = act;
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1, ref p2, ref p3, ref p4, ref p5, ref p6, ref p7, ref p8);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        public static bool RaiseStaticAction<T1, T2, T3, T4, T5, T6, T7, T8>(this RPCComponent component, SyncActionRegistration<T1, T2, T3, T4, T5, T6, T7, T8> act , ref T1 p1, ref T2 p2, ref T3 p3, ref T4 p4, ref T5 p5, ref T6 p6, ref T7 p7, ref T8 p8, EndpointId destination = default(EndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<RPCActionPacket>();
            bool result;
            try {
                var desc = act;
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1, ref p2, ref p3, ref p4, ref p5, ref p6, ref p7, ref p8);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
#endregion

    }
}