
using System;
using System.Collections.Generic;
using System.Reflection;
using Equinox.Utils.Stream;
using VRage;
namespace Equinox.Utils.Network
{
    public delegate void MySyncAction();
    public delegate void MySyncAction<in T1>(T1 p1);
    public delegate void MySyncAction<in T1, in T2>(T1 p1, T2 p2);
    public delegate void MySyncAction<in T1, in T2, in T3>(T1 p1, T2 p2, T3 p3);
    public delegate void MySyncAction<in T1, in T2, in T3, in T4>(T1 p1, T2 p2, T3 p3, T4 p4);
    public delegate void MySyncAction<in T1, in T2, in T3, in T4, in T5>(T1 p1, T2 p2, T3 p3, T4 p4, T5 p5);
    public delegate void MySyncAction<in T1, in T2, in T3, in T4, in T5, in T6>(T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6);
    public delegate void MySyncAction<in T1, in T2, in T3, in T4, in T5, in T6, in T7>(T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7);
    public delegate void MySyncAction<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8>(T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8);
    public static class MyRPCRegistry
    {
        public abstract class MySyncActionRegistrationBase
        {
            public abstract ulong HashKey { get; }
            public abstract void InvokeFrom(MyMemoryStream stream);
        }

        private static readonly FastResourceLock Lock = new FastResourceLock();
        private static readonly Dictionary<MemberInfo, MySyncActionRegistrationBase> ActionRegistration = new Dictionary<MemberInfo, MySyncActionRegistrationBase>();
        private static readonly Dictionary<ulong, MySyncActionRegistrationBase> HashKeyRegistration = new Dictionary<ulong, MySyncActionRegistrationBase>();

        public static MySyncActionRegistrationBase GetByKey(ulong hashKey)
        {
            return HashKeyRegistration[hashKey];
        }

#region AutoGenerated
        private static ulong ComputeHash(MySyncAction act)
        {
            var seed = (ulong) 104729;
            seed *= act.Method.Name.Hash64();
            return seed;
        }

        public class MySyncActionRegistration : MySyncActionRegistrationBase
        {
            public override ulong HashKey { get; }
            private readonly MySyncAction m_action;

            public MySyncActionRegistration(MySyncAction act)
            {
                HashKey = ComputeHash(act);
                m_action = act;
            }
            public void WriteArguments(MyMemoryStream output)
            {
            }

            public override void InvokeFrom(MyMemoryStream input)
            {
                m_action.Invoke();
            }
        }

        public static MySyncActionRegistration Register(MySyncAction act) {
            using(Lock.AcquireExclusiveUsing()) {
                var register = new MySyncActionRegistration(act);
                ActionRegistration.Add(act.Method, register);
                if (HashKeyRegistration.ContainsKey(register.HashKey))
                    throw new ArgumentException("Unable to register delegate.  Try using a unique name.");
                HashKeyRegistration.Add(register.HashKey, register);
                return register;
            }
        }

        public static void Unregister(MySyncAction act) {
            using(Lock.AcquireExclusiveUsing()) {
                HashKeyRegistration.Remove(ActionRegistration[act.Method].HashKey);
                ActionRegistration.Remove(act.Method);
            }
        }

        public static MySyncActionRegistration Get(MySyncAction act)
        {
            using(Lock.AcquireSharedUsing()) {
                MySyncActionRegistrationBase res;
                if (ActionRegistration.TryGetValue(act.Method, out res))
                    return (MySyncActionRegistration) res;
            }
            return null;
        }
        public static bool RaiseStaticAction(this MyRPCComponent component, MySyncAction act , MyEndpointId destination = default(MyEndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<MyRPCActionPacket>();
            bool result;
            try {
                var desc = Get(act);
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream );
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        public static bool RaiseStaticAction(this MyRPCComponent component, MySyncActionRegistration act , MyEndpointId destination = default(MyEndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<MyRPCActionPacket>();
            bool result;
            try {
                var desc = act;
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream );
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        private static ulong ComputeHash<T1>(MySyncAction<T1> act)
        {
            var seed = (ulong) 104729;
            seed *= act.Method.Name.Hash64();
            seed ^= typeof(T1).FullName.Hash64() * 52391;
            return seed;
        }

        public class MySyncActionRegistration<T1> : MySyncActionRegistrationBase
        {
            public override ulong HashKey { get; }
            private readonly MySyncAction<T1> m_action;
            private readonly MySerializer<T1> m_serializer1;

            public MySyncActionRegistration(MySyncAction<T1> act)
            {
                HashKey = ComputeHash(act);
                m_action = act;
                m_serializer1 = MySerializerRegistry.Get<T1>();
            }
            public void WriteArguments(MyMemoryStream output, ref T1 p1)
            {
                m_serializer1.Write(ref p1, output);
            }

            public override void InvokeFrom(MyMemoryStream input)
            {
                var p1 = default(T1);
                m_serializer1.Read(ref p1, input);
                m_action.Invoke(p1);
            }
        }

        public static MySyncActionRegistration<T1> Register<T1>(MySyncAction<T1> act) {
            using(Lock.AcquireExclusiveUsing()) {
                var register = new MySyncActionRegistration<T1>(act);
                ActionRegistration.Add(act.Method, register);
                if (HashKeyRegistration.ContainsKey(register.HashKey))
                    throw new ArgumentException("Unable to register delegate.  Try using a unique name.");
                HashKeyRegistration.Add(register.HashKey, register);
                return register;
            }
        }

        public static void Unregister<T1>(MySyncAction<T1> act) {
            using(Lock.AcquireExclusiveUsing()) {
                HashKeyRegistration.Remove(ActionRegistration[act.Method].HashKey);
                ActionRegistration.Remove(act.Method);
            }
        }

        public static MySyncActionRegistration<T1> Get<T1>(MySyncAction<T1> act)
        {
            using(Lock.AcquireSharedUsing()) {
                MySyncActionRegistrationBase res;
                if (ActionRegistration.TryGetValue(act.Method, out res))
                    return (MySyncActionRegistration<T1>) res;
            }
            return null;
        }
        public static bool RaiseStaticAction<T1>(this MyRPCComponent component, MySyncAction<T1> act , T1 p1, MyEndpointId destination = default(MyEndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<MyRPCActionPacket>();
            bool result;
            try {
                var desc = Get(act);
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        public static bool RaiseStaticAction<T1>(this MyRPCComponent component, MySyncAction<T1> act , ref T1 p1, MyEndpointId destination = default(MyEndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<MyRPCActionPacket>();
            bool result;
            try {
                var desc = Get(act);
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        public static bool RaiseStaticAction<T1>(this MyRPCComponent component, MySyncActionRegistration<T1> act , T1 p1, MyEndpointId destination = default(MyEndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<MyRPCActionPacket>();
            bool result;
            try {
                var desc = act;
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        public static bool RaiseStaticAction<T1>(this MyRPCComponent component, MySyncActionRegistration<T1> act , ref T1 p1, MyEndpointId destination = default(MyEndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<MyRPCActionPacket>();
            bool result;
            try {
                var desc = act;
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        private static ulong ComputeHash<T1, T2>(MySyncAction<T1, T2> act)
        {
            var seed = (ulong) 104729;
            seed *= act.Method.Name.Hash64();
            seed ^= typeof(T1).FullName.Hash64() * 52391;
            seed ^= typeof(T2).FullName.Hash64() * 45491;
            return seed;
        }

        public class MySyncActionRegistration<T1, T2> : MySyncActionRegistrationBase
        {
            public override ulong HashKey { get; }
            private readonly MySyncAction<T1, T2> m_action;
            private readonly MySerializer<T1> m_serializer1;
            private readonly MySerializer<T2> m_serializer2;

            public MySyncActionRegistration(MySyncAction<T1, T2> act)
            {
                HashKey = ComputeHash(act);
                m_action = act;
                m_serializer1 = MySerializerRegistry.Get<T1>();
                m_serializer2 = MySerializerRegistry.Get<T2>();
            }
            public void WriteArguments(MyMemoryStream output, ref T1 p1, ref T2 p2)
            {
                m_serializer1.Write(ref p1, output);
                m_serializer2.Write(ref p2, output);
            }

            public override void InvokeFrom(MyMemoryStream input)
            {
                var p1 = default(T1);
                m_serializer1.Read(ref p1, input);
                var p2 = default(T2);
                m_serializer2.Read(ref p2, input);
                m_action.Invoke(p1, p2);
            }
        }

        public static MySyncActionRegistration<T1, T2> Register<T1, T2>(MySyncAction<T1, T2> act) {
            using(Lock.AcquireExclusiveUsing()) {
                var register = new MySyncActionRegistration<T1, T2>(act);
                ActionRegistration.Add(act.Method, register);
                if (HashKeyRegistration.ContainsKey(register.HashKey))
                    throw new ArgumentException("Unable to register delegate.  Try using a unique name.");
                HashKeyRegistration.Add(register.HashKey, register);
                return register;
            }
        }

        public static void Unregister<T1, T2>(MySyncAction<T1, T2> act) {
            using(Lock.AcquireExclusiveUsing()) {
                HashKeyRegistration.Remove(ActionRegistration[act.Method].HashKey);
                ActionRegistration.Remove(act.Method);
            }
        }

        public static MySyncActionRegistration<T1, T2> Get<T1, T2>(MySyncAction<T1, T2> act)
        {
            using(Lock.AcquireSharedUsing()) {
                MySyncActionRegistrationBase res;
                if (ActionRegistration.TryGetValue(act.Method, out res))
                    return (MySyncActionRegistration<T1, T2>) res;
            }
            return null;
        }
        public static bool RaiseStaticAction<T1, T2>(this MyRPCComponent component, MySyncAction<T1, T2> act , T1 p1, T2 p2, MyEndpointId destination = default(MyEndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<MyRPCActionPacket>();
            bool result;
            try {
                var desc = Get(act);
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1, ref p2);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        public static bool RaiseStaticAction<T1, T2>(this MyRPCComponent component, MySyncAction<T1, T2> act , ref T1 p1, ref T2 p2, MyEndpointId destination = default(MyEndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<MyRPCActionPacket>();
            bool result;
            try {
                var desc = Get(act);
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1, ref p2);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        public static bool RaiseStaticAction<T1, T2>(this MyRPCComponent component, MySyncActionRegistration<T1, T2> act , T1 p1, T2 p2, MyEndpointId destination = default(MyEndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<MyRPCActionPacket>();
            bool result;
            try {
                var desc = act;
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1, ref p2);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        public static bool RaiseStaticAction<T1, T2>(this MyRPCComponent component, MySyncActionRegistration<T1, T2> act , ref T1 p1, ref T2 p2, MyEndpointId destination = default(MyEndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<MyRPCActionPacket>();
            bool result;
            try {
                var desc = act;
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1, ref p2);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        private static ulong ComputeHash<T1, T2, T3>(MySyncAction<T1, T2, T3> act)
        {
            var seed = (ulong) 104729;
            seed *= act.Method.Name.Hash64();
            seed ^= typeof(T1).FullName.Hash64() * 52391;
            seed ^= typeof(T2).FullName.Hash64() * 45491;
            seed ^= typeof(T3).FullName.Hash64() * 32401;
            return seed;
        }

        public class MySyncActionRegistration<T1, T2, T3> : MySyncActionRegistrationBase
        {
            public override ulong HashKey { get; }
            private readonly MySyncAction<T1, T2, T3> m_action;
            private readonly MySerializer<T1> m_serializer1;
            private readonly MySerializer<T2> m_serializer2;
            private readonly MySerializer<T3> m_serializer3;

            public MySyncActionRegistration(MySyncAction<T1, T2, T3> act)
            {
                HashKey = ComputeHash(act);
                m_action = act;
                m_serializer1 = MySerializerRegistry.Get<T1>();
                m_serializer2 = MySerializerRegistry.Get<T2>();
                m_serializer3 = MySerializerRegistry.Get<T3>();
            }
            public void WriteArguments(MyMemoryStream output, ref T1 p1, ref T2 p2, ref T3 p3)
            {
                m_serializer1.Write(ref p1, output);
                m_serializer2.Write(ref p2, output);
                m_serializer3.Write(ref p3, output);
            }

            public override void InvokeFrom(MyMemoryStream input)
            {
                var p1 = default(T1);
                m_serializer1.Read(ref p1, input);
                var p2 = default(T2);
                m_serializer2.Read(ref p2, input);
                var p3 = default(T3);
                m_serializer3.Read(ref p3, input);
                m_action.Invoke(p1, p2, p3);
            }
        }

        public static MySyncActionRegistration<T1, T2, T3> Register<T1, T2, T3>(MySyncAction<T1, T2, T3> act) {
            using(Lock.AcquireExclusiveUsing()) {
                var register = new MySyncActionRegistration<T1, T2, T3>(act);
                ActionRegistration.Add(act.Method, register);
                if (HashKeyRegistration.ContainsKey(register.HashKey))
                    throw new ArgumentException("Unable to register delegate.  Try using a unique name.");
                HashKeyRegistration.Add(register.HashKey, register);
                return register;
            }
        }

        public static void Unregister<T1, T2, T3>(MySyncAction<T1, T2, T3> act) {
            using(Lock.AcquireExclusiveUsing()) {
                HashKeyRegistration.Remove(ActionRegistration[act.Method].HashKey);
                ActionRegistration.Remove(act.Method);
            }
        }

        public static MySyncActionRegistration<T1, T2, T3> Get<T1, T2, T3>(MySyncAction<T1, T2, T3> act)
        {
            using(Lock.AcquireSharedUsing()) {
                MySyncActionRegistrationBase res;
                if (ActionRegistration.TryGetValue(act.Method, out res))
                    return (MySyncActionRegistration<T1, T2, T3>) res;
            }
            return null;
        }
        public static bool RaiseStaticAction<T1, T2, T3>(this MyRPCComponent component, MySyncAction<T1, T2, T3> act , T1 p1, T2 p2, T3 p3, MyEndpointId destination = default(MyEndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<MyRPCActionPacket>();
            bool result;
            try {
                var desc = Get(act);
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1, ref p2, ref p3);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        public static bool RaiseStaticAction<T1, T2, T3>(this MyRPCComponent component, MySyncAction<T1, T2, T3> act , ref T1 p1, ref T2 p2, ref T3 p3, MyEndpointId destination = default(MyEndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<MyRPCActionPacket>();
            bool result;
            try {
                var desc = Get(act);
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1, ref p2, ref p3);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        public static bool RaiseStaticAction<T1, T2, T3>(this MyRPCComponent component, MySyncActionRegistration<T1, T2, T3> act , T1 p1, T2 p2, T3 p3, MyEndpointId destination = default(MyEndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<MyRPCActionPacket>();
            bool result;
            try {
                var desc = act;
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1, ref p2, ref p3);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        public static bool RaiseStaticAction<T1, T2, T3>(this MyRPCComponent component, MySyncActionRegistration<T1, T2, T3> act , ref T1 p1, ref T2 p2, ref T3 p3, MyEndpointId destination = default(MyEndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<MyRPCActionPacket>();
            bool result;
            try {
                var desc = act;
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1, ref p2, ref p3);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        private static ulong ComputeHash<T1, T2, T3, T4>(MySyncAction<T1, T2, T3, T4> act)
        {
            var seed = (ulong) 104729;
            seed *= act.Method.Name.Hash64();
            seed ^= typeof(T1).FullName.Hash64() * 52391;
            seed ^= typeof(T2).FullName.Hash64() * 45491;
            seed ^= typeof(T3).FullName.Hash64() * 32401;
            seed ^= typeof(T4).FullName.Hash64() * 27953;
            return seed;
        }

        public class MySyncActionRegistration<T1, T2, T3, T4> : MySyncActionRegistrationBase
        {
            public override ulong HashKey { get; }
            private readonly MySyncAction<T1, T2, T3, T4> m_action;
            private readonly MySerializer<T1> m_serializer1;
            private readonly MySerializer<T2> m_serializer2;
            private readonly MySerializer<T3> m_serializer3;
            private readonly MySerializer<T4> m_serializer4;

            public MySyncActionRegistration(MySyncAction<T1, T2, T3, T4> act)
            {
                HashKey = ComputeHash(act);
                m_action = act;
                m_serializer1 = MySerializerRegistry.Get<T1>();
                m_serializer2 = MySerializerRegistry.Get<T2>();
                m_serializer3 = MySerializerRegistry.Get<T3>();
                m_serializer4 = MySerializerRegistry.Get<T4>();
            }
            public void WriteArguments(MyMemoryStream output, ref T1 p1, ref T2 p2, ref T3 p3, ref T4 p4)
            {
                m_serializer1.Write(ref p1, output);
                m_serializer2.Write(ref p2, output);
                m_serializer3.Write(ref p3, output);
                m_serializer4.Write(ref p4, output);
            }

            public override void InvokeFrom(MyMemoryStream input)
            {
                var p1 = default(T1);
                m_serializer1.Read(ref p1, input);
                var p2 = default(T2);
                m_serializer2.Read(ref p2, input);
                var p3 = default(T3);
                m_serializer3.Read(ref p3, input);
                var p4 = default(T4);
                m_serializer4.Read(ref p4, input);
                m_action.Invoke(p1, p2, p3, p4);
            }
        }

        public static MySyncActionRegistration<T1, T2, T3, T4> Register<T1, T2, T3, T4>(MySyncAction<T1, T2, T3, T4> act) {
            using(Lock.AcquireExclusiveUsing()) {
                var register = new MySyncActionRegistration<T1, T2, T3, T4>(act);
                ActionRegistration.Add(act.Method, register);
                if (HashKeyRegistration.ContainsKey(register.HashKey))
                    throw new ArgumentException("Unable to register delegate.  Try using a unique name.");
                HashKeyRegistration.Add(register.HashKey, register);
                return register;
            }
        }

        public static void Unregister<T1, T2, T3, T4>(MySyncAction<T1, T2, T3, T4> act) {
            using(Lock.AcquireExclusiveUsing()) {
                HashKeyRegistration.Remove(ActionRegistration[act.Method].HashKey);
                ActionRegistration.Remove(act.Method);
            }
        }

        public static MySyncActionRegistration<T1, T2, T3, T4> Get<T1, T2, T3, T4>(MySyncAction<T1, T2, T3, T4> act)
        {
            using(Lock.AcquireSharedUsing()) {
                MySyncActionRegistrationBase res;
                if (ActionRegistration.TryGetValue(act.Method, out res))
                    return (MySyncActionRegistration<T1, T2, T3, T4>) res;
            }
            return null;
        }
        public static bool RaiseStaticAction<T1, T2, T3, T4>(this MyRPCComponent component, MySyncAction<T1, T2, T3, T4> act , T1 p1, T2 p2, T3 p3, T4 p4, MyEndpointId destination = default(MyEndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<MyRPCActionPacket>();
            bool result;
            try {
                var desc = Get(act);
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1, ref p2, ref p3, ref p4);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        public static bool RaiseStaticAction<T1, T2, T3, T4>(this MyRPCComponent component, MySyncAction<T1, T2, T3, T4> act , ref T1 p1, ref T2 p2, ref T3 p3, ref T4 p4, MyEndpointId destination = default(MyEndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<MyRPCActionPacket>();
            bool result;
            try {
                var desc = Get(act);
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1, ref p2, ref p3, ref p4);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        public static bool RaiseStaticAction<T1, T2, T3, T4>(this MyRPCComponent component, MySyncActionRegistration<T1, T2, T3, T4> act , T1 p1, T2 p2, T3 p3, T4 p4, MyEndpointId destination = default(MyEndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<MyRPCActionPacket>();
            bool result;
            try {
                var desc = act;
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1, ref p2, ref p3, ref p4);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        public static bool RaiseStaticAction<T1, T2, T3, T4>(this MyRPCComponent component, MySyncActionRegistration<T1, T2, T3, T4> act , ref T1 p1, ref T2 p2, ref T3 p3, ref T4 p4, MyEndpointId destination = default(MyEndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<MyRPCActionPacket>();
            bool result;
            try {
                var desc = act;
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1, ref p2, ref p3, ref p4);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        private static ulong ComputeHash<T1, T2, T3, T4, T5>(MySyncAction<T1, T2, T3, T4, T5> act)
        {
            var seed = (ulong) 104729;
            seed *= act.Method.Name.Hash64();
            seed ^= typeof(T1).FullName.Hash64() * 52391;
            seed ^= typeof(T2).FullName.Hash64() * 45491;
            seed ^= typeof(T3).FullName.Hash64() * 32401;
            seed ^= typeof(T4).FullName.Hash64() * 27953;
            seed ^= typeof(T5).FullName.Hash64() * 76801;
            return seed;
        }

        public class MySyncActionRegistration<T1, T2, T3, T4, T5> : MySyncActionRegistrationBase
        {
            public override ulong HashKey { get; }
            private readonly MySyncAction<T1, T2, T3, T4, T5> m_action;
            private readonly MySerializer<T1> m_serializer1;
            private readonly MySerializer<T2> m_serializer2;
            private readonly MySerializer<T3> m_serializer3;
            private readonly MySerializer<T4> m_serializer4;
            private readonly MySerializer<T5> m_serializer5;

            public MySyncActionRegistration(MySyncAction<T1, T2, T3, T4, T5> act)
            {
                HashKey = ComputeHash(act);
                m_action = act;
                m_serializer1 = MySerializerRegistry.Get<T1>();
                m_serializer2 = MySerializerRegistry.Get<T2>();
                m_serializer3 = MySerializerRegistry.Get<T3>();
                m_serializer4 = MySerializerRegistry.Get<T4>();
                m_serializer5 = MySerializerRegistry.Get<T5>();
            }
            public void WriteArguments(MyMemoryStream output, ref T1 p1, ref T2 p2, ref T3 p3, ref T4 p4, ref T5 p5)
            {
                m_serializer1.Write(ref p1, output);
                m_serializer2.Write(ref p2, output);
                m_serializer3.Write(ref p3, output);
                m_serializer4.Write(ref p4, output);
                m_serializer5.Write(ref p5, output);
            }

            public override void InvokeFrom(MyMemoryStream input)
            {
                var p1 = default(T1);
                m_serializer1.Read(ref p1, input);
                var p2 = default(T2);
                m_serializer2.Read(ref p2, input);
                var p3 = default(T3);
                m_serializer3.Read(ref p3, input);
                var p4 = default(T4);
                m_serializer4.Read(ref p4, input);
                var p5 = default(T5);
                m_serializer5.Read(ref p5, input);
                m_action.Invoke(p1, p2, p3, p4, p5);
            }
        }

        public static MySyncActionRegistration<T1, T2, T3, T4, T5> Register<T1, T2, T3, T4, T5>(MySyncAction<T1, T2, T3, T4, T5> act) {
            using(Lock.AcquireExclusiveUsing()) {
                var register = new MySyncActionRegistration<T1, T2, T3, T4, T5>(act);
                ActionRegistration.Add(act.Method, register);
                if (HashKeyRegistration.ContainsKey(register.HashKey))
                    throw new ArgumentException("Unable to register delegate.  Try using a unique name.");
                HashKeyRegistration.Add(register.HashKey, register);
                return register;
            }
        }

        public static void Unregister<T1, T2, T3, T4, T5>(MySyncAction<T1, T2, T3, T4, T5> act) {
            using(Lock.AcquireExclusiveUsing()) {
                HashKeyRegistration.Remove(ActionRegistration[act.Method].HashKey);
                ActionRegistration.Remove(act.Method);
            }
        }

        public static MySyncActionRegistration<T1, T2, T3, T4, T5> Get<T1, T2, T3, T4, T5>(MySyncAction<T1, T2, T3, T4, T5> act)
        {
            using(Lock.AcquireSharedUsing()) {
                MySyncActionRegistrationBase res;
                if (ActionRegistration.TryGetValue(act.Method, out res))
                    return (MySyncActionRegistration<T1, T2, T3, T4, T5>) res;
            }
            return null;
        }
        public static bool RaiseStaticAction<T1, T2, T3, T4, T5>(this MyRPCComponent component, MySyncAction<T1, T2, T3, T4, T5> act , T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, MyEndpointId destination = default(MyEndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<MyRPCActionPacket>();
            bool result;
            try {
                var desc = Get(act);
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1, ref p2, ref p3, ref p4, ref p5);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        public static bool RaiseStaticAction<T1, T2, T3, T4, T5>(this MyRPCComponent component, MySyncAction<T1, T2, T3, T4, T5> act , ref T1 p1, ref T2 p2, ref T3 p3, ref T4 p4, ref T5 p5, MyEndpointId destination = default(MyEndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<MyRPCActionPacket>();
            bool result;
            try {
                var desc = Get(act);
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1, ref p2, ref p3, ref p4, ref p5);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        public static bool RaiseStaticAction<T1, T2, T3, T4, T5>(this MyRPCComponent component, MySyncActionRegistration<T1, T2, T3, T4, T5> act , T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, MyEndpointId destination = default(MyEndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<MyRPCActionPacket>();
            bool result;
            try {
                var desc = act;
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1, ref p2, ref p3, ref p4, ref p5);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        public static bool RaiseStaticAction<T1, T2, T3, T4, T5>(this MyRPCComponent component, MySyncActionRegistration<T1, T2, T3, T4, T5> act , ref T1 p1, ref T2 p2, ref T3 p3, ref T4 p4, ref T5 p5, MyEndpointId destination = default(MyEndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<MyRPCActionPacket>();
            bool result;
            try {
                var desc = act;
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1, ref p2, ref p3, ref p4, ref p5);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        private static ulong ComputeHash<T1, T2, T3, T4, T5, T6>(MySyncAction<T1, T2, T3, T4, T5, T6> act)
        {
            var seed = (ulong) 104729;
            seed *= act.Method.Name.Hash64();
            seed ^= typeof(T1).FullName.Hash64() * 52391;
            seed ^= typeof(T2).FullName.Hash64() * 45491;
            seed ^= typeof(T3).FullName.Hash64() * 32401;
            seed ^= typeof(T4).FullName.Hash64() * 27953;
            seed ^= typeof(T5).FullName.Hash64() * 76801;
            seed ^= typeof(T6).FullName.Hash64() * 76913;
            return seed;
        }

        public class MySyncActionRegistration<T1, T2, T3, T4, T5, T6> : MySyncActionRegistrationBase
        {
            public override ulong HashKey { get; }
            private readonly MySyncAction<T1, T2, T3, T4, T5, T6> m_action;
            private readonly MySerializer<T1> m_serializer1;
            private readonly MySerializer<T2> m_serializer2;
            private readonly MySerializer<T3> m_serializer3;
            private readonly MySerializer<T4> m_serializer4;
            private readonly MySerializer<T5> m_serializer5;
            private readonly MySerializer<T6> m_serializer6;

            public MySyncActionRegistration(MySyncAction<T1, T2, T3, T4, T5, T6> act)
            {
                HashKey = ComputeHash(act);
                m_action = act;
                m_serializer1 = MySerializerRegistry.Get<T1>();
                m_serializer2 = MySerializerRegistry.Get<T2>();
                m_serializer3 = MySerializerRegistry.Get<T3>();
                m_serializer4 = MySerializerRegistry.Get<T4>();
                m_serializer5 = MySerializerRegistry.Get<T5>();
                m_serializer6 = MySerializerRegistry.Get<T6>();
            }
            public void WriteArguments(MyMemoryStream output, ref T1 p1, ref T2 p2, ref T3 p3, ref T4 p4, ref T5 p5, ref T6 p6)
            {
                m_serializer1.Write(ref p1, output);
                m_serializer2.Write(ref p2, output);
                m_serializer3.Write(ref p3, output);
                m_serializer4.Write(ref p4, output);
                m_serializer5.Write(ref p5, output);
                m_serializer6.Write(ref p6, output);
            }

            public override void InvokeFrom(MyMemoryStream input)
            {
                var p1 = default(T1);
                m_serializer1.Read(ref p1, input);
                var p2 = default(T2);
                m_serializer2.Read(ref p2, input);
                var p3 = default(T3);
                m_serializer3.Read(ref p3, input);
                var p4 = default(T4);
                m_serializer4.Read(ref p4, input);
                var p5 = default(T5);
                m_serializer5.Read(ref p5, input);
                var p6 = default(T6);
                m_serializer6.Read(ref p6, input);
                m_action.Invoke(p1, p2, p3, p4, p5, p6);
            }
        }

        public static MySyncActionRegistration<T1, T2, T3, T4, T5, T6> Register<T1, T2, T3, T4, T5, T6>(MySyncAction<T1, T2, T3, T4, T5, T6> act) {
            using(Lock.AcquireExclusiveUsing()) {
                var register = new MySyncActionRegistration<T1, T2, T3, T4, T5, T6>(act);
                ActionRegistration.Add(act.Method, register);
                if (HashKeyRegistration.ContainsKey(register.HashKey))
                    throw new ArgumentException("Unable to register delegate.  Try using a unique name.");
                HashKeyRegistration.Add(register.HashKey, register);
                return register;
            }
        }

        public static void Unregister<T1, T2, T3, T4, T5, T6>(MySyncAction<T1, T2, T3, T4, T5, T6> act) {
            using(Lock.AcquireExclusiveUsing()) {
                HashKeyRegistration.Remove(ActionRegistration[act.Method].HashKey);
                ActionRegistration.Remove(act.Method);
            }
        }

        public static MySyncActionRegistration<T1, T2, T3, T4, T5, T6> Get<T1, T2, T3, T4, T5, T6>(MySyncAction<T1, T2, T3, T4, T5, T6> act)
        {
            using(Lock.AcquireSharedUsing()) {
                MySyncActionRegistrationBase res;
                if (ActionRegistration.TryGetValue(act.Method, out res))
                    return (MySyncActionRegistration<T1, T2, T3, T4, T5, T6>) res;
            }
            return null;
        }
        public static bool RaiseStaticAction<T1, T2, T3, T4, T5, T6>(this MyRPCComponent component, MySyncAction<T1, T2, T3, T4, T5, T6> act , T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, MyEndpointId destination = default(MyEndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<MyRPCActionPacket>();
            bool result;
            try {
                var desc = Get(act);
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1, ref p2, ref p3, ref p4, ref p5, ref p6);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        public static bool RaiseStaticAction<T1, T2, T3, T4, T5, T6>(this MyRPCComponent component, MySyncAction<T1, T2, T3, T4, T5, T6> act , ref T1 p1, ref T2 p2, ref T3 p3, ref T4 p4, ref T5 p5, ref T6 p6, MyEndpointId destination = default(MyEndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<MyRPCActionPacket>();
            bool result;
            try {
                var desc = Get(act);
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1, ref p2, ref p3, ref p4, ref p5, ref p6);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        public static bool RaiseStaticAction<T1, T2, T3, T4, T5, T6>(this MyRPCComponent component, MySyncActionRegistration<T1, T2, T3, T4, T5, T6> act , T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, MyEndpointId destination = default(MyEndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<MyRPCActionPacket>();
            bool result;
            try {
                var desc = act;
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1, ref p2, ref p3, ref p4, ref p5, ref p6);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        public static bool RaiseStaticAction<T1, T2, T3, T4, T5, T6>(this MyRPCComponent component, MySyncActionRegistration<T1, T2, T3, T4, T5, T6> act , ref T1 p1, ref T2 p2, ref T3 p3, ref T4 p4, ref T5 p5, ref T6 p6, MyEndpointId destination = default(MyEndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<MyRPCActionPacket>();
            bool result;
            try {
                var desc = act;
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1, ref p2, ref p3, ref p4, ref p5, ref p6);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        private static ulong ComputeHash<T1, T2, T3, T4, T5, T6, T7>(MySyncAction<T1, T2, T3, T4, T5, T6, T7> act)
        {
            var seed = (ulong) 104729;
            seed *= act.Method.Name.Hash64();
            seed ^= typeof(T1).FullName.Hash64() * 52391;
            seed ^= typeof(T2).FullName.Hash64() * 45491;
            seed ^= typeof(T3).FullName.Hash64() * 32401;
            seed ^= typeof(T4).FullName.Hash64() * 27953;
            seed ^= typeof(T5).FullName.Hash64() * 76801;
            seed ^= typeof(T6).FullName.Hash64() * 76913;
            seed ^= typeof(T7).FullName.Hash64() * 77029;
            return seed;
        }

        public class MySyncActionRegistration<T1, T2, T3, T4, T5, T6, T7> : MySyncActionRegistrationBase
        {
            public override ulong HashKey { get; }
            private readonly MySyncAction<T1, T2, T3, T4, T5, T6, T7> m_action;
            private readonly MySerializer<T1> m_serializer1;
            private readonly MySerializer<T2> m_serializer2;
            private readonly MySerializer<T3> m_serializer3;
            private readonly MySerializer<T4> m_serializer4;
            private readonly MySerializer<T5> m_serializer5;
            private readonly MySerializer<T6> m_serializer6;
            private readonly MySerializer<T7> m_serializer7;

            public MySyncActionRegistration(MySyncAction<T1, T2, T3, T4, T5, T6, T7> act)
            {
                HashKey = ComputeHash(act);
                m_action = act;
                m_serializer1 = MySerializerRegistry.Get<T1>();
                m_serializer2 = MySerializerRegistry.Get<T2>();
                m_serializer3 = MySerializerRegistry.Get<T3>();
                m_serializer4 = MySerializerRegistry.Get<T4>();
                m_serializer5 = MySerializerRegistry.Get<T5>();
                m_serializer6 = MySerializerRegistry.Get<T6>();
                m_serializer7 = MySerializerRegistry.Get<T7>();
            }
            public void WriteArguments(MyMemoryStream output, ref T1 p1, ref T2 p2, ref T3 p3, ref T4 p4, ref T5 p5, ref T6 p6, ref T7 p7)
            {
                m_serializer1.Write(ref p1, output);
                m_serializer2.Write(ref p2, output);
                m_serializer3.Write(ref p3, output);
                m_serializer4.Write(ref p4, output);
                m_serializer5.Write(ref p5, output);
                m_serializer6.Write(ref p6, output);
                m_serializer7.Write(ref p7, output);
            }

            public override void InvokeFrom(MyMemoryStream input)
            {
                var p1 = default(T1);
                m_serializer1.Read(ref p1, input);
                var p2 = default(T2);
                m_serializer2.Read(ref p2, input);
                var p3 = default(T3);
                m_serializer3.Read(ref p3, input);
                var p4 = default(T4);
                m_serializer4.Read(ref p4, input);
                var p5 = default(T5);
                m_serializer5.Read(ref p5, input);
                var p6 = default(T6);
                m_serializer6.Read(ref p6, input);
                var p7 = default(T7);
                m_serializer7.Read(ref p7, input);
                m_action.Invoke(p1, p2, p3, p4, p5, p6, p7);
            }
        }

        public static MySyncActionRegistration<T1, T2, T3, T4, T5, T6, T7> Register<T1, T2, T3, T4, T5, T6, T7>(MySyncAction<T1, T2, T3, T4, T5, T6, T7> act) {
            using(Lock.AcquireExclusiveUsing()) {
                var register = new MySyncActionRegistration<T1, T2, T3, T4, T5, T6, T7>(act);
                ActionRegistration.Add(act.Method, register);
                if (HashKeyRegistration.ContainsKey(register.HashKey))
                    throw new ArgumentException("Unable to register delegate.  Try using a unique name.");
                HashKeyRegistration.Add(register.HashKey, register);
                return register;
            }
        }

        public static void Unregister<T1, T2, T3, T4, T5, T6, T7>(MySyncAction<T1, T2, T3, T4, T5, T6, T7> act) {
            using(Lock.AcquireExclusiveUsing()) {
                HashKeyRegistration.Remove(ActionRegistration[act.Method].HashKey);
                ActionRegistration.Remove(act.Method);
            }
        }

        public static MySyncActionRegistration<T1, T2, T3, T4, T5, T6, T7> Get<T1, T2, T3, T4, T5, T6, T7>(MySyncAction<T1, T2, T3, T4, T5, T6, T7> act)
        {
            using(Lock.AcquireSharedUsing()) {
                MySyncActionRegistrationBase res;
                if (ActionRegistration.TryGetValue(act.Method, out res))
                    return (MySyncActionRegistration<T1, T2, T3, T4, T5, T6, T7>) res;
            }
            return null;
        }
        public static bool RaiseStaticAction<T1, T2, T3, T4, T5, T6, T7>(this MyRPCComponent component, MySyncAction<T1, T2, T3, T4, T5, T6, T7> act , T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, MyEndpointId destination = default(MyEndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<MyRPCActionPacket>();
            bool result;
            try {
                var desc = Get(act);
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1, ref p2, ref p3, ref p4, ref p5, ref p6, ref p7);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        public static bool RaiseStaticAction<T1, T2, T3, T4, T5, T6, T7>(this MyRPCComponent component, MySyncAction<T1, T2, T3, T4, T5, T6, T7> act , ref T1 p1, ref T2 p2, ref T3 p3, ref T4 p4, ref T5 p5, ref T6 p6, ref T7 p7, MyEndpointId destination = default(MyEndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<MyRPCActionPacket>();
            bool result;
            try {
                var desc = Get(act);
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1, ref p2, ref p3, ref p4, ref p5, ref p6, ref p7);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        public static bool RaiseStaticAction<T1, T2, T3, T4, T5, T6, T7>(this MyRPCComponent component, MySyncActionRegistration<T1, T2, T3, T4, T5, T6, T7> act , T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, MyEndpointId destination = default(MyEndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<MyRPCActionPacket>();
            bool result;
            try {
                var desc = act;
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1, ref p2, ref p3, ref p4, ref p5, ref p6, ref p7);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        public static bool RaiseStaticAction<T1, T2, T3, T4, T5, T6, T7>(this MyRPCComponent component, MySyncActionRegistration<T1, T2, T3, T4, T5, T6, T7> act , ref T1 p1, ref T2 p2, ref T3 p3, ref T4 p4, ref T5 p5, ref T6 p6, ref T7 p7, MyEndpointId destination = default(MyEndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<MyRPCActionPacket>();
            bool result;
            try {
                var desc = act;
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1, ref p2, ref p3, ref p4, ref p5, ref p6, ref p7);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        private static ulong ComputeHash<T1, T2, T3, T4, T5, T6, T7, T8>(MySyncAction<T1, T2, T3, T4, T5, T6, T7, T8> act)
        {
            var seed = (ulong) 104729;
            seed *= act.Method.Name.Hash64();
            seed ^= typeof(T1).FullName.Hash64() * 52391;
            seed ^= typeof(T2).FullName.Hash64() * 45491;
            seed ^= typeof(T3).FullName.Hash64() * 32401;
            seed ^= typeof(T4).FullName.Hash64() * 27953;
            seed ^= typeof(T5).FullName.Hash64() * 76801;
            seed ^= typeof(T6).FullName.Hash64() * 76913;
            seed ^= typeof(T7).FullName.Hash64() * 77029;
            seed ^= typeof(T8).FullName.Hash64() * 77167;
            return seed;
        }

        public class MySyncActionRegistration<T1, T2, T3, T4, T5, T6, T7, T8> : MySyncActionRegistrationBase
        {
            public override ulong HashKey { get; }
            private readonly MySyncAction<T1, T2, T3, T4, T5, T6, T7, T8> m_action;
            private readonly MySerializer<T1> m_serializer1;
            private readonly MySerializer<T2> m_serializer2;
            private readonly MySerializer<T3> m_serializer3;
            private readonly MySerializer<T4> m_serializer4;
            private readonly MySerializer<T5> m_serializer5;
            private readonly MySerializer<T6> m_serializer6;
            private readonly MySerializer<T7> m_serializer7;
            private readonly MySerializer<T8> m_serializer8;

            public MySyncActionRegistration(MySyncAction<T1, T2, T3, T4, T5, T6, T7, T8> act)
            {
                HashKey = ComputeHash(act);
                m_action = act;
                m_serializer1 = MySerializerRegistry.Get<T1>();
                m_serializer2 = MySerializerRegistry.Get<T2>();
                m_serializer3 = MySerializerRegistry.Get<T3>();
                m_serializer4 = MySerializerRegistry.Get<T4>();
                m_serializer5 = MySerializerRegistry.Get<T5>();
                m_serializer6 = MySerializerRegistry.Get<T6>();
                m_serializer7 = MySerializerRegistry.Get<T7>();
                m_serializer8 = MySerializerRegistry.Get<T8>();
            }
            public void WriteArguments(MyMemoryStream output, ref T1 p1, ref T2 p2, ref T3 p3, ref T4 p4, ref T5 p5, ref T6 p6, ref T7 p7, ref T8 p8)
            {
                m_serializer1.Write(ref p1, output);
                m_serializer2.Write(ref p2, output);
                m_serializer3.Write(ref p3, output);
                m_serializer4.Write(ref p4, output);
                m_serializer5.Write(ref p5, output);
                m_serializer6.Write(ref p6, output);
                m_serializer7.Write(ref p7, output);
                m_serializer8.Write(ref p8, output);
            }

            public override void InvokeFrom(MyMemoryStream input)
            {
                var p1 = default(T1);
                m_serializer1.Read(ref p1, input);
                var p2 = default(T2);
                m_serializer2.Read(ref p2, input);
                var p3 = default(T3);
                m_serializer3.Read(ref p3, input);
                var p4 = default(T4);
                m_serializer4.Read(ref p4, input);
                var p5 = default(T5);
                m_serializer5.Read(ref p5, input);
                var p6 = default(T6);
                m_serializer6.Read(ref p6, input);
                var p7 = default(T7);
                m_serializer7.Read(ref p7, input);
                var p8 = default(T8);
                m_serializer8.Read(ref p8, input);
                m_action.Invoke(p1, p2, p3, p4, p5, p6, p7, p8);
            }
        }

        public static MySyncActionRegistration<T1, T2, T3, T4, T5, T6, T7, T8> Register<T1, T2, T3, T4, T5, T6, T7, T8>(MySyncAction<T1, T2, T3, T4, T5, T6, T7, T8> act) {
            using(Lock.AcquireExclusiveUsing()) {
                var register = new MySyncActionRegistration<T1, T2, T3, T4, T5, T6, T7, T8>(act);
                ActionRegistration.Add(act.Method, register);
                if (HashKeyRegistration.ContainsKey(register.HashKey))
                    throw new ArgumentException("Unable to register delegate.  Try using a unique name.");
                HashKeyRegistration.Add(register.HashKey, register);
                return register;
            }
        }

        public static void Unregister<T1, T2, T3, T4, T5, T6, T7, T8>(MySyncAction<T1, T2, T3, T4, T5, T6, T7, T8> act) {
            using(Lock.AcquireExclusiveUsing()) {
                HashKeyRegistration.Remove(ActionRegistration[act.Method].HashKey);
                ActionRegistration.Remove(act.Method);
            }
        }

        public static MySyncActionRegistration<T1, T2, T3, T4, T5, T6, T7, T8> Get<T1, T2, T3, T4, T5, T6, T7, T8>(MySyncAction<T1, T2, T3, T4, T5, T6, T7, T8> act)
        {
            using(Lock.AcquireSharedUsing()) {
                MySyncActionRegistrationBase res;
                if (ActionRegistration.TryGetValue(act.Method, out res))
                    return (MySyncActionRegistration<T1, T2, T3, T4, T5, T6, T7, T8>) res;
            }
            return null;
        }
        public static bool RaiseStaticAction<T1, T2, T3, T4, T5, T6, T7, T8>(this MyRPCComponent component, MySyncAction<T1, T2, T3, T4, T5, T6, T7, T8> act , T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, MyEndpointId destination = default(MyEndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<MyRPCActionPacket>();
            bool result;
            try {
                var desc = Get(act);
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1, ref p2, ref p3, ref p4, ref p5, ref p6, ref p7, ref p8);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        public static bool RaiseStaticAction<T1, T2, T3, T4, T5, T6, T7, T8>(this MyRPCComponent component, MySyncAction<T1, T2, T3, T4, T5, T6, T7, T8> act , ref T1 p1, ref T2 p2, ref T3 p3, ref T4 p4, ref T5 p5, ref T6 p6, ref T7 p7, ref T8 p8, MyEndpointId destination = default(MyEndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<MyRPCActionPacket>();
            bool result;
            try {
                var desc = Get(act);
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1, ref p2, ref p3, ref p4, ref p5, ref p6, ref p7, ref p8);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        public static bool RaiseStaticAction<T1, T2, T3, T4, T5, T6, T7, T8>(this MyRPCComponent component, MySyncActionRegistration<T1, T2, T3, T4, T5, T6, T7, T8> act , T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, MyEndpointId destination = default(MyEndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<MyRPCActionPacket>();
            bool result;
            try {
                var desc = act;
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1, ref p2, ref p3, ref p4, ref p5, ref p6, ref p7, ref p8);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
        public static bool RaiseStaticAction<T1, T2, T3, T4, T5, T6, T7, T8>(this MyRPCComponent component, MySyncActionRegistration<T1, T2, T3, T4, T5, T6, T7, T8> act , ref T1 p1, ref T2 p2, ref T3 p3, ref T4 p4, ref T5 p5, ref T6 p6, ref T7 p7, ref T8 p8, MyEndpointId destination = default(MyEndpointId), bool reliable = true)
        {
            var packet = component.Network.AllocatePacket<MyRPCActionPacket>();
            bool result;
            try {
                var desc = act;
                packet.Stream.WriteHead = packet.Stream.ReadHead = 0;
                packet.Stream.Write(desc.HashKey);
                desc.WriteArguments(packet.Stream,  ref p1, ref p2, ref p3, ref p4, ref p5, ref p6, ref p7, ref p8);
                result = component.Network.SendMessageGeneric(packet, destination, reliable);
            } catch {
                result = false;
            } finally {
                component.Network.ReturnPacket(packet);
            }
            return result;
        }
#endregion

    }
}